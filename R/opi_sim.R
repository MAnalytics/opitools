#' @title To simulate the expected sentiment (opinion) distribution
#' @description Given a text document with two underlying subjects
#' A and B, this function simulates (replicates) the opinions associated
#' with B as the expected opinions (from A). The resulting
#' text document is referred to as the `Expected Sentiment
#' Document (ESD)` (Adepeju and Jimoh, 2021).
#' This exercise allow the impacts of B to be tested on A
#' (see function \code{opi_mpact} for details).
#' @param osd_data [list] An observed sentiment document
#' of (n x 3) dimension, in which `n` is the number of
#' text records that are successfully classified as
#' positive, negative or neutral. An \code{osd_data} must be
#' derived from the text document. Column 1 shows the ID of the
#' text record, column 2 shows the shows the sentiment
#' classes of records (i.e. positive, negative, or neutral).
#' Column 3 indicate the presence  (`present`) or absence
#' (`absent`) of secondary keyword in each text record.
#' @param nsim [integer] Number of replicas of the OSD to generate.
#' Recommended values: 99, 999, 9999, and so on. Since the run time
#' is proportional to the number of replicas, a lower number of
#' simulation is recommended. Default: \code{99}.
#' @param metric [integer] Metric to utilize for the calculation
#' of the expected opinion score. Default: \code{1}. See the documentation
#' of \code{metric} parameter of \code{opi_score} function for details.
#' To calculate p-values, the argument of \code{metric} parameter
#' here must correspond to that of \code{opi_score} function.
#' @param fun A user-defined function if parameter \code{metric}
#' is set as \code{5}. Also, see the documentation
#' of \code{fun} parameter of \code{opi_score} function for details.
#' @param quiet (TRUE or FALSE) To suppress processing
#' messages. Default: \code{TRUE}.
#' @usage opi_sim(osd_data, nsim=99, metric = 1, fun = NULL, quiet=TRUE)
#' @details Employs randomization testing approach in
#' order to generate expected distribution of the opinion scores
#' that signifies the absence of effects of secondary subject.
#' Simply, the randomization testing involves generating a large
#' number of ESD, referred here to as “replicas”, \code{S}.
#' A replica is generated by randomizing the sentiment assignment of
#' text document that contain the secondary keywords in accordance
#' with the probabilities derived from text document that do not
#' contain those keywords.
#' @return Returns a list of expected opinion scores based on
#' the number of simulated, i.e. \code{nsim} specified.
#' @references (1) Adepeju, M. and Jimoh, F. (2021). An Analytical
#' Framework for Measuring Inequality in the Public Opinions on
#' Policing – Assessing the impacts of COVID-19 Pandemic using
#' Twitter Data. https://doi.org/10.31235/osf.io/c32qh
#' @importFrom tidytext unnest_tokens
#' @importFrom tibble tibble
#' @importFrom magrittr %>%
#' @export
#'
opi_sim <- function(osd_data, nsim=99, metric = 1, fun = NULL, quiet=TRUE){

  #options(warn=-1)

  #check if randomization is too small
  if(nsim < 9){
    stop("Number of simulation (nsim) is too small!!")
  }

  #check metric
  if(!metric %in% c(1:5)){
    stop(paste("Metric parameter can only assume values from",
               "1, 2, 3, 4, 5", sep=" "))
  }

  #check if a user-defined function is inputted
  if(metric == 5 & is.null(fun)){
    stop("A function (equation) is required in the parameter 'fun'")
  }

  if(metric %in% c(1:4) & !is.null(fun)){
    print(paste("Warning: `fun` parameter will not be used!!",
                "Otherwise, set`metric = 5`", sep=" "))
  }



    nsim_exp_scores <- NULL

    for(m in seq_len(nsim)){ #m<-1


      #create backup of the all 'neutrals'
      #for simulation, neutral remains untouched
      #to be appended back later
      neutral_osd <- osd_data %>%
        dplyr::filter(sentiment == 'neutral')

      #filter neutral
      #simul is based on permutation
      #of positv and negat sentimnt labels
      p1 <- osd_data %>%
        dplyr::filter(sentiment!="neutral")%>%
        dplyr::group_by(keywords)%>%
        dplyr::mutate(nnrow=n())%>%
        mutate(prob1=nnrow/nrow(osd_data))%>% #prob of absent
        ungroup()%>%
        dplyr::group_by(keywords, sentiment) %>%
        dplyr::mutate(pos_neg_count=n())%>%
        mutate(prob2=pos_neg_count/nnrow)##%>%

      len_excl_neutral <- nrow(p1)

      ab_class_sent <- p1[which(p1$keywords == "absent"),2]

      length_present_group <- length(which(p1$keywords == "present"))

      #now collate the unique probabilities of 'absent' class
      p1_prob <- p1 %>%
        dplyr::filter(keywords == "absent")%>%
        dplyr::distinct(sentiment, .keep_all = TRUE)%>%
        dplyr::select(sentiment, prob2)


      if(nsim == 1){
        set.seed(len_excl_neutral)
        new_ex_class_sent = sample(p1_prob$sentiment, length_present_group, replace=TRUE, prob = p1_prob$prob2)
        #new_ex_class_sent = sample(c("negative", "positive"), sum(unique(p1$nnrow)), replace=TRUE, prob = c(unique(p1$prob_new_assign),(1-unique(p1$prob_new_assign))))
      }

      if(nsim > 1){
      #generate samples of present class using the prob of absent class
        if(m == 1){
          set.seed(len_excl_neutral)
          new_ex_class_sent = sample(p1_prob$sentiment, length_present_group, replace=TRUE, prob = p1_prob$prob2)
          #new_ex_class_sent = sample(c("negative", "positive"), sum(unique(p1$nnrow)), replace=TRUE, prob = c(unique(p1$prob_new_assign),(1-unique(p1$prob_new_assign))))
        }

        if(m > 1){
          #set.seed(nrow(data))
          new_ex_class_sent = sample(p1_prob$sentiment, length_present_group, replace=TRUE, prob = p1_prob$prob2)
          #new_ex_class_sent = sample(c("negative", "positive"), sum(unique(p1$nnrow)), replace=TRUE, prob = c(unique(p1$prob_new_assign),(1-unique(p1$prob_new_assign))))
        }

      }

      #unique(p1$nnrow)[1]


      new_ex_class_sent

      new_sentiment_list <- c(new_ex_class_sent, as.vector(unlist(ab_class_sent))) #length(new_sentiment_list)#nrow(p1)
      #new_sentiment_list <- new_ex_class_sent


      #p1[which(p1$keywords == "present"), 3] <- new_ex_class_sent

      final_p1 <- data.frame(cbind(p1, sentiment2=new_sentiment_list))

      head(final_p1)

      #expected
      final_p1_ESD <- final_p1 %>%
        dplyr::select(ID, sentiment, keywords, sentiment2)%>%
        mutate(sentiment = sentiment2)%>%
        dplyr::select(-c(sentiment2))

      #now, prepare compute different opinion scores

      #append neutral list
      final_p1_ESD <- rbind(final_p1_ESD, neutral_osd)


      afinn_ESD <- final_p1_ESD %>%
        group_by(sentiment)%>%
        #count the proportion of
        dplyr::summarise(n=n())


      #to ensure that each value exist
      sent_gr <- data.frame(sentiment=c("negative", "positive", "neutral"),
                            n=0)
      wh <- sent_gr$sentiment %in% afinn_ESD$sentiment

      #
      afinn_ESD <- afinn_ESD %>%
        bind_rows(sent_gr[which(wh==FALSE),])


      #calculate opinion score
      if (metric %in% c(1:4)){

        if(metric == 1){

          total_n <- sum(afinn_ESD$n)

          afinn_ESD <- afinn_ESD %>%
            dplyr::rename(No_of_text_records=n)

          P <- afinn_ESD[which(afinn_ESD$sentiment == "positive"),2]
          N <- afinn_ESD[which(afinn_ESD$sentiment == "negative"),2]
          PD <- round(((P - N)/(P + N))*100,digits = 2)

          }
        if(metric == 2){
          P <- afinn_ESD[which(afinn_ESD$sentiment == "positive"),2]
          N <- afinn_ESD[which(afinn_ESD$sentiment == "negative"),2]
          O <- afinn_ESD[which(afinn_ESD$sentiment == "neutral"),2]
          PD <- round((abs(P - N) / (P + N + O))*100,digits = 2)

        }

        if(metric == 3){
          P <- afinn_ESD[which(afinn_ESD$sentiment == "positive"),2]
          N <- afinn_ESD[which(afinn_ESD$sentiment == "negative"),2]
          O <- afinn_ESD[which(afinn_ESD$sentiment == "neutral"),2]
          PD <- round((P / (P + N + O))*100, digits = 2)

        }

        if(metric == 4){
          P <- afinn_ESD[which(afinn_ESD$sentiment == "positive"),2]
          N <- afinn_ESD[which(afinn_ESD$sentiment == "negative"),2]
          O <- afinn_ESD[which(afinn_ESD$sentiment == "neutral"),2]
          PD <- round((N / (P + N + O))*100, digits = 2)

        }

      }

      if(metric == 5){
        P <- afinn_ESD[which(afinn_ESD$sentiment == "positive"),2]
        N <- afinn_ESD[which(afinn_ESD$sentiment == "negative"),2]
        O <- afinn_ESD[which(afinn_ESD$sentiment == "neutral"),2]
        PD <- as.numeric(fun(P, N, O))

    }
      nsim_exp_scores <- c(nsim_exp_scores,
                           as.numeric(as.character(PD)))

      if(quiet == FALSE){
        flush.console()
        print(paste("No. of simulations completed:", m, sep=","))
      }
      if(quiet == TRUE){
        #do nothing
      }
    }

    return(nsim_exp_scores)

  }


#}
